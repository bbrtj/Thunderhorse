package Thunderhorse::Router::Location;

use v5.40;
use Mooish::Base -standard;

use Future::AsyncAwait;
use Gears::X;

extends 'Gears::Router::Location::SigilMatch';

has option 'method' => (
	isa => Str,
);

# TODO: ensure names are unique
has param 'name' => (
	isa => Str,
	lazy => 1,
);

has param 'to' => (
	isa => Str | CodeRef,
);

has param 'order' => (
	isa => Int,
	default => 0,
);

has param 'pagi' => (
	isa => Bool,
	default => false,
);

has param 'controller' => (
	isa => ConsumerOf ['Thunderhorse::Routable'],
);

sub BUILD ($self, $)
{
	Gears::X->raise('controller has no action ' . $self->to)
		unless $self->get_destination;

	# build name eagerly
	$self->name;
}

sub _build_name ($self)
{
	my $method = $self->method // 'ANY';
	my $pattern = $self->pattern;
	my $id = $self->router->get_next_route_id;

	# autogenerated location name should be readable, but unique
	return "_${method}_${pattern}_${id}";
}

sub get_destination ($self)
{
	my $to = $self->to;
	return $to if ref $to eq 'CODE';
	return $self->controller->can($self->to);
}

# TODO: cache this
# TODO: move this somewhere else (but not to match)
sub pagify ($self, $matched)
{
	my $dest = $self->get_destination;
	if ($self->pagi) {
		# TODO: this should always mark as rendered
		# TODO: adjust PAGI (like Kelp did to PSGI)
		return $dest;
	}
	else {
		weaken $self;

		return async sub ($scope, $receive, $send) {
			Gears::X->raise('bad PAGI execution chain, not a thunderhorse app')
				unless exists $scope->{thunderhorse};

			my $context = $scope->{thunderhorse}{context};
			$context->set_pagi([$scope, $receive, $send]);

			my $res = $context->res;
			try {
				my $result = $dest->($self->controller, $context, $matched->@*);
				$result = await $result
					if $result isa 'Future';

				if (defined $result && !$res->sent) {
					# TODO: result should be an array? (status, content_type, content)
					await $res->status(200)->html($result);
				}
			}
			catch ($ex) {
				die $ex unless $ex isa 'Gears::X::HTTP';
				# TODO: proper message
				await $res->status($ex->status)->text('Error')
				# TODO: log $ex->message
			}
		};
	}
}

sub compare ($self, $path, $method)
{
	return undef if $self->has_method && $self->method ne $method;
	return $self->SUPER::compare($path);
}

